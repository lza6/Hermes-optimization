import hashlib
import uuid
import time
from ..config import config
from ..database import fetch_one, execute_query, fetch_all
from ..utils.logger import logger

class AuthService:
    @staticmethod
    async def validate_key(key: str) -> bool:
        if not key: return False
        
        token = key[7:] if key.startswith("Bearer ") else key
        
        if token == config.HERMES_SECRET:
            return True
        
        key_hash = hashlib.sha256(token.encode()).hexdigest()
        
        row = await fetch_one("SELECT id FROM hermes_keys WHERE key_hash = ?", (key_hash,))
        if row:
            # Fire and forget update or await it? Await for safety.
            await execute_query("UPDATE hermes_keys SET lastUsedAt = ? WHERE id = ?", (int(time.time() * 1000), row["id"]))
            return True
        
        logger.warning(f"无效的访问尝试 (Invalid access attempt) hash={key_hash}")
        return False

    @staticmethod
    def generate_key() -> str:
        return f"sk-{uuid.uuid4()}"

    @staticmethod
    async def store_key(key: str, description: str = "Generated by Admin") -> str:
        key_id = str(uuid.uuid4())
        key_hash = hashlib.sha256(key.encode()).hexdigest()
        created_at = int(time.time() * 1000)
        
        # Check existing
        row = await fetch_one("SELECT id FROM hermes_keys WHERE key_hash = ?", (key_hash,))
        if row:
            logger.warning(f"[AuthService] Key hash exists. Skipping. ID={row['id']}")
            return row["id"]
        
        await execute_query("""
            INSERT INTO hermes_keys (id, key_hash, description, createdAt)
            VALUES (?, ?, ?, ?)
        """, (key_id, key_hash, description, created_at))
        return key_id

    @staticmethod
    async def get_generated_keys(filters: dict = None) -> list:
        sql = "SELECT id, description, createdAt, lastUsedAt FROM hermes_keys"
        params = []
        conditions = []
        
        if filters:
            if filters.get("description"):
                conditions.append("description LIKE ?")
                params.append(f"%{filters['description']}%")
            if filters.get("id"):
                conditions.append("id LIKE ?")
                params.append(f"%{filters['id']}%")
        
        if conditions:
            sql += " WHERE " + " OR ".join(conditions)
        
        sql += " ORDER BY createdAt DESC"
        
        rows = await fetch_all(sql, tuple(params))
        return [dict(row) for row in rows]

    @staticmethod
    async def delete_key(key_id: str) -> bool:
        # execute_query doesn't return rowcount easily unless we check changes?
        # aiosqlite execute returns cursor, await cursor.rowcount helps.
        # But execute_query helper returns None.
        # Let's verify existence or just use custom query here.
        from ..database import DB_PATH
        import aiosqlite
        
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute("DELETE FROM hermes_keys WHERE id = ?", (key_id,))
            await db.commit()
            return cursor.rowcount > 0
